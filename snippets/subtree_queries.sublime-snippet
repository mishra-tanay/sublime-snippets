<snippet>
	<content><![CDATA[
vector < int > euler;
vector<int> adj[MAXN];
int in[MAXN];
int out[MAXN];
ll val[MAXN];
int _time = 1;
void get_euler(int i, int p) {
    in[i] = _time++;
    euler.push_back(val[i]);
    for (auto it : adj[i]) {
        if (it != p) {
            get_euler(it, i);
            _time++;
        }
    }
    euler.push_back(val[i]);
    out[i] = _time;
}
ll segtree[8 * MAXN];
ll lazyarray[8 * MAXN];
void build(int curr, int s, int e) {
    if (s == e) {
        segtree[curr] = euler[s];
        return ;
    }
    int mid = (s + e) / 2;
    build(2 * curr, s, mid);
    build(2 * curr + 1, mid + 1, e);
    segtree[curr] = segtree[2 * curr] + segtree[2 * curr + 1];
}
void update_range(int curr, int s, int e, int l , int r, ll val) {
    if (lazyarray[curr] != 0)
    {
        segtree[curr] += lazyarray[curr];
        if (s != e) { // Not a leaf node , Propagagate further
            lazyarray[2 * curr] += lazyarray[curr];
            lazyarray[2 * curr + 1] += lazyarray[curr];
        }
        lazyarray[curr] = 0;
    }
    if (s > e || s > r || e < l) {
        return ;
    }
    if ( s >= l && e <= r) { //Completly lies in range
        segtree[curr] += val;
        if ( s != e) {
            lazyarray[2 * curr] += val;
            lazyarray[2 * curr + 1] += val;
        }
        return;
    }
    int mid = (s + e) / 2;
    update_range(2 * curr, s, mid, l, r, val);
    update_range(2 * curr + 1, mid + 1, e, l , r, val);
    segtree[curr] = segtree[2 * curr] + segtree[2 * curr + 1];
}
ll query_range(int curr, int s, int e, int l , int r) {
    if (lazyarray[curr] != 0)
    {
        segtree[curr] += lazyarray[curr];
        if (s != e) { // Not a leaf node , Propagagate further
            lazyarray[2 * curr] += lazyarray[curr];
            lazyarray[2 * curr + 1] += lazyarray[curr];
        }
        lazyarray[curr] = 0;
    }
    if (s > e || s > r || e < l) {
        return 0;
    }
    if ( s >= l && e <= r) { //Completly lies in range
        return segtree[curr];
    }
    int mid = (s + e) / 2;
    return query_range(2 * curr, s, mid, l, r) + query_range(2 * curr + 1, mid + 1, e, l , r);
}

void updateSubtree(int v, int val) {
    int l = in[v];
    int r = out[v];
    update_range(1, 1, _time , l, r, val);
}

ll querySubtree(int v) {
    int l = in[v];
    int r = out[v];
    return query_range(1, 1, _time, l, r);
}

void updateNode(int v, int val) {
    int l = in[v];
    int r = out[v];
    update_range(1, 1, _time, l, l, val);
    update_range(1, 1, _time, r, r, val);
}

ll queryNode(int v) {
    int l = in[v];
    return query_range(1, 1, _time, l, l);
}
// build(1,1,_time);

]]></content>
	<!-- Optional: Set a tabTrigger to define how to trigger the snippet -->
<tabTrigger>sublime_subtreequeries</tabTrigger>
	<!-- Optional: Set a scope to limit where the snippet will trigger -->
	<!-- <scope>source.python</scope> -->
</snippet>
